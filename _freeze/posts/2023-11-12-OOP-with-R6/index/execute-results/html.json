{
  "hash": "1325e3f2279ddb62cb5cb6b90af2cee0",
  "result": {
    "markdown": "---\ntitle: \"R Users Probably Don't Need to Know OOP\"\ndescription: \"The R6 package brings forth the elegance of object-oriented programming (OOP) to a traditionally 'stats first' language. That said, do you need to know OOP to be a successful data scientist? No.\"\ndate: 11-20-2023\ncategories:\n  - r6\n---\n\n\n# OOP with R6\n\n::: columns\n::: {.column width=\"80%\"}\nThe [R6 package](https://r6.r-lib.org/) brings forth the elegance of object-oriented programming (OOP) to a traditionally 'stats first' language. The _Tidy Wizard_, a barely-configured GPT variant that I crafted specializing in the R language, has the following to say about R6:\n\n* It bestows upon the user the ability to craft sophisticated and modular software, a boon in various business scenarios.\n:::\n::: {.column width=\"5%\"}\n:::\n::: {.column width=\"15%\"}\n![](images/logo.svg){.preview-image}\n:::\n:::\n\nWhen meeting data scientists in the wild, they're almost always Python users and they often ask me the rhetorical question of \"can R do OOP and encapsulation?\" I used to be embarrassed about this... Did I miss some mission critical component of data science in grad school? Have I been learning from the wrong books and tutorials?\n\nHaving worked alongside amazing software engineers over recent years, I've come to realize OOP is fundamental in computer science education. The de facto OOP nature of Python makes the transition from C/C++/Java to Python a breeze and delight. This is one of the many reasons why we see so much OOP development in data science organizations _by_ Python-based data science practitioners and educators. But what if you don't have a formal software background and gravitated to R for statistics, functional programming, and data science? \n\n<aside>\n[Interact with the Tidy Wizard](https://chat.openai.com/g/g-QvPl8z04e-tidy-wizard) if you're a paying ChatGPT Plus customer! I'm developing a Shiny app for anyone to interact with a more robust version of the wizard via API (and without the Gandalf-speak... trust me when I say it gets old üòÖ)\n</aside>\n\nMy thoughts on this topic will differ from others in the R community, likely from folks that have formal computer science / software engineering backgrounds. I do not have a formal CS background, so bear with me while I work through this heresy: *You don't need to know OOP to be a successful data scientist.*\n\nIn data science, would knowing OOP help your future career prospects? Probably; _Probably_ in the same way a PhD _might_ help you climb the corporate ladder more quickly. For me personally (and again, as a primary R user), not knowing the intricacies of OOP hasn't slowed me down from interactive web app development, ML training / production at scale (and containerization via Docker), parallelized / vectorized function writing, package development, NLP and deep learning, etc.\n\nCopying from Hadley Wickham's _Advanced R_, he shares the following insights:\n\n> Generally in R, functional programming is much more important than object-oriented programming, because you typically solve complex problems by decomposing them into simple functions, not simple objects. Nevertheless, there are important reasons to learn each of the three systems:\n>\n* S3 allows your functions to return rich results with user-friendly display and programmer-friendly internals. S3 is used throughout base R, so it‚Äôs important to master if you want to extend base R functions to work with new types of input.<br><br>\n>\n* R6 provides a standardised way to escape R‚Äôs copy-on-modify semantics. This is particularly important if you want to model objects that exist independently of R. Today, a common need for R6 is to model data that comes from a web API, and where changes come from inside or outside of R.<br><br>\n>\n* S4 is a rigorous system that forces you to think carefully about program design. It‚Äôs particularly well-suited for building large systems that evolve over time and will receive contributions from many programmers. This is why it is used by the Bioconductor project, so another reason to learn S4 is to equip you to contribute to that project.\n\n# Additional Resources\n\nAfter a pattern of writing, modifying, and deleting a more robust background section for object-oriented systems with R, I've decided to instead point you to some of the best resources I've come across:\n\n* The _Advanced R_ book, by Hadley Wickham, includes several chapters on OOP with R including base types, S3, R6, S4, and a trade-offs chapter. The [_Introduction to OOP_](https://adv-r.hadley.nz/oo.html) section is a great place to start for a high-level overview.\n\n* Dario Radeƒçiƒá published a phenomenal [complete R6 guide](https://appsilon.com/oop-in-r-with-r6/) for Appsilon's blog. It's a bookmark-worthy R6 overview that touches on its classes and constructors/methods including `$new()`, `$initialize()`, `$print()`, and more. \n\n# R6 Example Use Cases\n\nWith the assistance of the Tidy Wizard, let's dive into some examples that aim to \"illuminate a few practical applications where R6 can lend its prowess.\" üßô\n\n## CRM Systems\n\nWhen we ponder Customer Relationship Management, we find ourselves amidst a vast sea of data, encompassing customer interactions, preferences, transaction histories, and much more. In the traditional approach, this data might be stored in spreadsheets or databases as tabular data. While this method is straightforward, it often leads to a fragmented view of the customer, with data scattered across multiple tables or sheets.\n\nHerein lies the profound advantage of employing R6 in a CRM context:\n\n*Unified Customer View*: By defining an R6 class for a customer, you encapsulate all relevant information and behaviors related to that customer in one place. This approach fosters a holistic view of each customer, integrating data from various sources. It allows for more coherent and comprehensive analysis and decision-making.\n\n*Behavior Encapsulation*: With R6, you're not just storing data; you're also encapsulating behaviors. For instance, an R6 class for a customer could include methods to calculate lifetime value, predict churn, or even trigger personalized marketing actions. This encapsulation of behavior with data enriches the CRM's capabilities.\n\n*Flexibility and Scalability*: R6's object-oriented nature allows for more scalable and adaptable solutions. As business needs evolve, you can extend or modify the R6 classes without overhauling your entire data structure. This flexibility is crucial in the ever-changing business landscape.\n\n*Interactivity and Automation*: R6 classes can interact with each other, enabling automated workflows. For instance, a class representing an email campaign can interact with the customer class to send personalized emails, log interactions, and update customer profiles, all in an automated manner.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Defining a Customer class\nCustomer <- R6::R6Class(\"Customer\",\n    public = list(\n        name = NULL,\n        email = NULL,\n        transaction_history = list(),\n        initialize = function(name, email) {\n            self$name <- name\n            self$email <- email\n        },\n        record_transaction = function(transaction) {\n            self$transaction_history <- c(self$transaction_history, list(transaction))\n        },\n        calculate_lifetime_value = function() {\n          self$transaction_history |> \n            purrr::map_dbl(~ .x$amount) |> \n            sum()\n        }\n    )\n)\n\n# Example usage\ncustomer1 <- Customer$new(name = \"John Doe\", email = \"john@example.com\")\ncustomer1$record_transaction(list(date = \"2021-01-01\", amount = 100))\ncustomer1$record_transaction(list(date = \"2021-02-01\", amount = 150))\nlifetime_value <- customer1$calculate_lifetime_value()\n\nprint(lifetime_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 250\n```\n\n\n:::\n:::\n\n\nIn this enriched example, our Customer class now not only stores basic information but also tracks transaction history and calculates the lifetime value. This enriched model provides a more dynamic and insightful perspective on the customer, far surpassing the static nature of spreadsheets or basic tabular data.\n\n## Financial Modeling\n\nLet's craft an R6 class that models a portfolio of financial instruments, each with its own characteristics and behaviors. This portfolio can include various types of investments like stocks, bonds, and mutual funds, each represented by their own R6 classes.\n\nThe beauty of using R6 in this context lies in its ability to encapsulate the complexities of financial instruments within their respective classes, thereby making the overall portfolio management more intuitive and robust. Let's delve into this with a code example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\n\n# Define a generic FinancialInstrument class\nFinancialInstrument <- R6::R6Class(\"FinancialInstrument\",\n    public = list(\n        identifier = NULL,\n        principal = NULL,\n        initialize = function(identifier, principal) {\n            self$identifier = identifier\n            self$principal = principal\n        },\n        calculate_return = function() {\n            # Placeholder for return calculation\n        }\n    )\n)\n\n# Extend FinancialInstrument for specific types\nStock <- R6::R6Class(\"Stock\", inherit = FinancialInstrument,\n    public = list(\n        dividend_yield = NULL,\n        initialize = function(identifier, principal, dividend_yield) {\n            super$initialize(identifier, principal)\n            self$dividend_yield = dividend_yield\n        },\n        calculate_return = function() {\n            return(self$principal * self$dividend_yield)\n        }\n    )\n)\n\nBond <- R6::R6Class(\"Bond\", inherit = FinancialInstrument,\n    public = list(\n        interest_rate = NULL,\n        initialize = function(identifier, principal, interest_rate) {\n            super$initialize(identifier, principal)\n            self$interest_rate = interest_rate\n        },\n        calculate_return = function() {\n            return(self$principal * self$interest_rate)\n        }\n    )\n)\n\n# Define a Portfolio class that can hold multiple financial instruments\nPortfolio <- R6::R6Class(\"Portfolio\",\n    public = list(\n        instruments = list(),\n        add_instrument = function(instrument) {\n            self$instruments[[instrument$identifier]] <- instrument\n        },\n        total_return = function() {\n          self$instruments |> \n            purrr::map_dbl(\\(x) x$calculate_return()) |> \n            sum()\n        }\n    )\n)\n\n# Example usage\nportfolio <- Portfolio$new()\nportfolio$add_instrument(Stock$new(\"AAPL\", 10000, 0.02))\nportfolio$add_instrument(Bond$new(\"US-Gov\", 5000, 0.03))\n\ntotal_return <- portfolio$total_return()\nprint(total_return)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 350\n```\n\n\n:::\n:::\n\n\nIn this expanded scenario, we have:\n\n* A base class `FinancialInstrument` that defines a generic financial instrument.\n* Derived classes `Stock` and `Bond` that inherit from `FinancialInstrument` and implement specific behaviors, such as different ways of calculating returns.\n* A `Portfolio` class that can contain a collection of different financial instruments. It can calculate the total return of the portfolio by summing the returns of each individual instrument.\n\nThis object-oriented approach provided by R6 allows for clear separation and encapsulation of the logic for each type of financial instrument. It makes the code modular, easier to understand, and maintain. For a business leader or data analyst, this translates to a system that is more adaptable to new types of financial instruments and changing financial models, ultimately aiding in making more informed investment decisions.\n\n## Library System\n\nLet's develop a simplified system for managing a library which includes tracking books, patrons, and book loans. This example will demonstrate how R6 can be used to model real-world entities and their interactions.\n\nIn our library system, we'll have three main classes:\n\n1. *Book*: Represents a book in the library.\n2. *Patron*: Represents a library member who can borrow books.\n3. *Library*: Manages the collection of books and patrons, and handles book loans.\n\nHere's the R code for this use case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\n\n# Book class\nBook <- R6::R6Class(\"Book\",\n    public = list(\n        title = NULL,\n        author = NULL,\n        is_loaned = FALSE,\n        initialize = function(title, author) {\n            self$title <- title\n            self$author <- author\n            self$is_loaned <- FALSE\n        },\n        loan = function() {\n            self$is_loaned <- TRUE\n        },\n        return_book = function() {\n            self$is_loaned <- FALSE\n        }\n    )\n)\n\n# Patron class\nPatron <- R6::R6Class(\"Patron\",\n    public = list(\n        name = NULL,\n        books_loaned = list(),\n        transaction_history = list(),\n        initialize = function(name) {\n            self$name <- name\n            self$books_loaned <- list()\n            self$transaction_history <- list()\n        },\n        borrow_book = function(book) {\n            if (!book$is_loaned) {\n                book$loan()\n                self$books_loaned[[book$title]] <- book\n                self$transaction_history <- c(self$transaction_history, \n                                              list(paste(Sys.time(), \": Borrowed\", book$title)))\n            } else {\n                message(\"This book is currently loaned out.\")\n            }\n        },\n        return_book = function(book) {\n            book$return_book()\n            self$books_loaned[[book$title]] <- NULL\n            self$transaction_history <- c(self$transaction_history, \n                                          list(paste(Sys.time(), \": Returned\", book$title)))\n        },\n        get_transaction_history = function() {\n            return(self$transaction_history)\n        }\n    )\n)\n\n# Library class\nLibrary <- R6::R6Class(\"Library\",\n    public = list(\n        books = list(),\n        patrons = list(),\n        initialize = function() {\n            self$books <- list()\n            self$patrons <- list()\n        },\n        add_book = function(book) {\n            self$books[[book$title]] <- book\n        },\n        add_patron = function(patron) {\n            self$patrons[[patron$name]] <- patron\n        }\n    )\n)\n\n# Example usage\nlibrary_system <- Library$new()\nbook1 <- Book$new(\"The Great Gatsby\", \"F. Scott Fitzgerald\")\nbook2 <- Book$new(\"1984\", \"George Orwell\")\npatron1 <- Patron$new(\"John Doe\")\n\nlibrary_system$add_book(book1)\nlibrary_system$add_book(book2)\nlibrary_system$add_patron(patron1)\n\n# John Doe borrows \"The Great Gatsby\"\npatron1$borrow_book(library_system$books[[\"The Great Gatsby\"]])\n\n# Check if the book is loaned\nprint(library_system$books[[\"The Great Gatsby\"]]$is_loaned)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# John Doe returns \"The Great Gatsby\"\npatron1$return_book(library_system$books[[\"The Great Gatsby\"]])\n\n# Check if the book is loaned\nprint(library_system$books[[\"The Great Gatsby\"]]$is_loaned)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# View John Doe's transaction history\nprint(patron1$get_transaction_history())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"2023-11-20 12:50:37.377001 : Borrowed The Great Gatsby\"\n\n[[2]]\n[1] \"2023-11-20 12:50:37.378382 : Returned The Great Gatsby\"\n```\n\n\n:::\n:::\n\n\nIn the above example:\n\n* The `Book` class represents a book with methods to loan and return it\n* The `Patron` class represents a library member who can borrow and return books\n  * The `Patron` class includes a `transaction_history` list to record each borrowing and returning action\n  * Methods `borrow_book` and `return_book` append a descriptive string and timestamp to the `transaction_history` each time they are called\n  * `get_transaction_history` retrieves and displays the transaction history\n* The `Library` class manages the collection of books and patrons\n  * It allows adding books and patrons to the library\n\nThis code provides a simple yet effective demonstration of how R6 can be used to model and manage real-world entities and their interactions, showcasing the utility of object-oriented programming in R. Any time John Doe borrows or returns a book, the transaction is recorded. You can then view all his transactions by calling the `get_transaction_history` method on his Patron object.\n\n# Closing Remarks\n\nAs of 2023, the landscape of R programming has evolved significantly, offering a rich ecosystem of programming paradigms and tools. OOP, with its implementation through R6 classes, is a notable part of this ecosystem. Understanding the pros and cons of OOP in R can be enlightening for an R user deciding whether to delve into this paradigm.\n\n**Pros of OOP with R6:**\n\n1. **Encapsulation and Modularity:** OOP allows for bundling data and methods that operate on the data within objects. This encapsulation makes code more modular and easier to maintain, a boon for complex and large-scale applications.\n2. **Reusability and Extensibility:** Classes and objects in OOP promote code reusability. You can define a class once and create many objects, each with its own state. Moreover, inheritance in R6 allows for extending existing classes, fostering an extensible design.\n3. **Clarity in Code Structure:** OOP can lead to code that mirrors real-world entities, making it more intuitive. This can be especially beneficial in domains where modeling complex entities and their interactions is crucial, like in financial modeling or supply chain management.\n\n**Cons of OOP with R6:**\n\n1. **Learning Curve:** For those accustomed to functional programming or R's vectorized operations, OOP presents a different mindset, requiring time to learn and understand, especially for those new to programming.\n2. **Overhead and Complexity:** OOP can introduce additional complexity and overhead. For simple tasks or data analysis, the straightforward approach of functional programming or vectorized operations in R might be more efficient.\n3. **Interoperability with Tidyverse:** While R6 is powerful, it does not always seamlessly integrate with the tidyverse, a collection of packages widely used in R for data science tasks. This can lead to a mix of coding styles and potential inefficiencies.\n\n**Relevance in 2023:**\n\nIn 2023, an R user, particularly one focused on data analysis, might not need to deeply understand OOP and R6. The rise of the tidyverse, which emphasizes functional programming paradigms and a declarative style of coding, has provided tools that are often more aligned with the typical tasks of data manipulation, visualization, and analysis. These tools are generally more accessible and require less boilerplate code than OOP.\n\nThe tidyverse's philosophy and syntax have been widely adopted in the R community, especially for data science applications. Consequently, many modern R users can perform a vast majority of their work effectively without needing OOP.\n\nHowever, for those working on more complex software development projects in R, such as building large-scale applications or designing systems that require robust modeling of real-world entities, OOP and R6 can be invaluable tools. They provide a level of organization and scalability that is hard to achieve with functional programming alone.\n\nIn summary, while understanding OOP and R6 can be beneficial for specific use cases, many R users in 2023, particularly those focused on data analysis and the tidyverse, may not find it necessary to delve deeply into these concepts. The choice largely depends on the specific needs and scope of one's projects in R.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}