{
  "hash": "f996ef1ea7e20398c8b3dcbd92604c14",
  "result": {
    "markdown": "---\ntitle: \"webR via Quarto Extensions\"\ndescription: \"webR has been on my mind recently... With the recent release of webR 0.2.0, it's time to dive in!\"\ndate: 08-23-2023\ncategories:\n  - webR\n  - dplyr\nimage: images/webR.png\nengine: knitr\nwebr: \n  show-startup-message: false\n  show-header-message: false\n  home-dir: '/'\n  packages: ['dplyr']\nfilters:\n  - webr\nservice-worker-url: '/posts/2023-08-21-webr-via-quarto-extensions/'\n---\n\n\n![](images/webr_bart.jpeg){.preview-image}\n\nImagine you've written a program in R. It's simple and does exactly what you want but now, you wish to make it available for many people on the web, allowing them to run it within their web browsers. The challenge is that web browsers don't natively understand R code.\n\n# WebAssembly\n\nTraditionally, web browsers understand JavaScript as the primary language to run any dynamic operations. If you wanted to run code in a browser, you'd need to rewrite it in JavaScript. Re-writing code for every language to JavaScript is tedious and not efficient. This is where [WebAssembly](https://webassembly.org/) (or \"wasm\") comes into play.\n\nWebAssembly introduces a new type of code that can be run in modern web browsers. It is designed as a low-level virtual machine that runs code at near-native speed. What's fascinating about WebAssembly is that it isnâ€™t written by hand; instead, other languages (like C, C++, Rust, Python, R, and more) can be compiled to WebAssembly.\n\nIn essence, WebAssembly allows you to take code from languages other than JavaScript, compile it into a format that the browser can understand, and then run it efficiently.\n\n# webR\n\nCompiling R to wasm was hypothetical even just a few years ago but is now possible via [webR](https://docs.r-wasm.org/webr/latest/). Being able to run R functions within a web browser without the need for an R interpreter on the user's end feels game changing.\n\nwebR is enabling R developers to bring their applications, algorithms, and visualizations to broader audiences via the web. R + wasm is definitely in the early stages of development and new use cases are being released daily by the data science and web development communities. For now, I'm just enjoying learning the basics and thinking about potential use cases.\n\n# Demo\n\nFor the examples below, I'm running webR via a Quarto extension. I'm following James Balamuta's documentation on GitHub to learn how to use his [webR Code Extension for Quarto](https://github.com/coatless/quarto-webr) before I dive deeper into the internals of webR. I'm basically using a plug-and-play implementation of webR for Quarto ðŸš€. My goal is to start here and eventually use the raw webR framework for more robust applications.\n\nAnd so, enjoy some webr-enabled executable code chunks in a static Quarto doc!\n\n```{webr-r}\n# review structure of the mtcars object\nstr(mtcars)\n```\n\n```{webr-r}\n# show column names\ncolnames(mtcars)\n```\n\n```{webr-r}\n# install and load dplyr (10-20s)\nwebr::install(\"dplyr\")\nlibrary(dplyr)\n```\n\n```{webr-r}\n# round up all numeric variables\nrounded_up_mtcars <- mtcars |> \n  mutate(across(where(is.numeric), \\(x) ceiling(x)))\n\n# re-review structure of newly munged object\nstr(rounded_up_mtcars)\n```\n\nTHAT WAS FUN! Enjoy, and happy learning.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}